*dmltips.txt*       Dan's personal Vim tips                 *mytips* *dmltips*

==============================================================================
Shortcuts (normal mode)

------------------------------------------------------------------------------
Window resizing

    :res          resize to maximum available
    :res -N       downsize by count N
    :res +N       upsize by count N
    :winc =       make all windows as equal as possible

------------------------------------------------------------------------------
History views

    q/     search history
    q:     command history

    type ':' then up/down arrow to see command history
    type '/' then up/down arrow to see search history

    ^F     switch from command line to command history window

    :args   Shows command line you used to start vim

------------------------------------------------------------------------------
Case coercion (cr) - Abolish plugin

    type   convert to

    crc    camelCase
    crm    MixedCase
    cr_    snake_case
    crs    snake_case
    cru    SNAKE_UPPERCASE
    cr-    dash-case (irreversible)

------------------------------------------------------------------------------
Spell check

    :set spell!     Toggle spell check mode (also bound to ,s)
    ]s              Next error
    [s              Previous error
    z=              List of suggestions
    zg              Add to my dictionary (zug to undo)
    zw              Remove from my dictionary (zuw to undo)

------------------------------------------------------------------------------
Search and replace

    *       search for the word under the cursor
    #       ... and in reverse

    gd      go to declaration of variable under the cursor

    " 'find'
    f<c>    jump to next occurrence of char <c>
    F<c>    ... and in reverse
    " 'til' or 'until'
    t<c>    jump to position *left* of next occurrence of char <c>
    T<c>    ... and in reverse

    e       go to end of word (also works with v, c, d, etc.)
    b       go to beginning of word

    :%g/foo/m$      move all lines matching foo to end of file
                        % = global search
                        g = command
                        /foo/ = regex
                        m = move
                        $ = to end
                    you can do the same things with a NOT search
                    (conVerse) using v instead of g.

    :%g/foo/s/bar/zzz/g     for each line /foo/, replace bar with zzz.

    :s/foo/bar/     search/replace this line
    :%s/foo/bar/    search/replace entire file
        add g (/g) to end for global (also see :help gdefault)

    :s/\%V_/ /g     Add \%V to limit action to a *block* selection (by
                    default entire lines are affected even in ^v mode).

    &       repeat last :s command

    Abolish plugin provides 'Subvert' aka 'S' command:

        :S/box{,es}/bag{,s}/g

        Changes:
            box -> bag
            Box -> Bag
            BOX -> BAG
            boxes -> bags
            Boxes -> Bags
            BOXES -> BAGS

        :%S/facilit{y,ies}/building{,s}/g

        Changes:
            facility -> building
            FACILITIES -> BUILDINGS
            ... and so on

        Can be repeated with &
        Honors % for global application
        Honors ending flags such as 'g'

------------------------------------------------------------------------------
Navigating / jumping around

    ^       beginning of line ignoring leading whitespace (vs. '0')

    [{      jump back to opening brace of the current code block

    H       high (top) line on this page
    M       middle line on this page
    L       low (bottom) line on this page

    zt      keep cursor in place, but move that line to top of view
    zz      keep cursor in place, but move that line to middle of view
    zb      keep cursor in place, but move that line to bottom of view

    (, )    jump to start, end of current 'sentence'
    {, }    jump to start, end of current 'paragraph'

    `.      return to last line you edited
    '.      return to last line you edited

    g;      go to position of last change (again to go to change before...)
    g,      move through changelist in opposite direction

    ^O      move backward through jump list
    ^I      move forward through jump list

------------------------------------------------------------------------------
Copy and paste

    yyp     duplicate this line

    ddP     delete line, then paste *back into place* leaving copy on buffer
            though that's the same as yy isn't it?

    y       yank
    Y       yank line (isn't this the same as yy ?)

    cc      cut entire line and enter insert mode ("change line")

------------------------------------------------------------------------------
General editing

    c<x>    change
    ce      change to end of word
    c$      change to end of line
    C       change to end of line
    c/foo   change until match 'foo'

    K       go to man page for the word under the cursor (disabled)

    s       delete this char, then enter insert mode (xi)
    S       erase entire line, sub with new (0C or 0Da)

    ctrl-a  increment number under cursor
    ctrl-x  decrement number under cursor

    ga      show char under cursor as dec, hex, oct ASCII.

------------------------------------------------------------------------------
Indenting

    =       syntax-aware reindent of selection
    ==      syntax-aware reindent of line
    gg=G    syntax reindent entire file

------------------------------------------------------------------------------
Folds

    zo      open closed fold under cursor
    zc      close current fold region
    zR      open "(R)ip open?" all folds
    zM      close "(M)inimize?" all folds

------------------------------------------------------------------------------
Selections and matching on things

    B matches a block, so in a block you can say (a is 'around' or
    'this block plus enclosing delimiters, if any')
        >aB     ident the current block
        <aB     outdent the current block
        daB     delete current block
        caB     change current block

    viw     select a word ('word' delimited not whitespace-delimited)
    viW     select a word, whitespace delimited

    gv      reselect last selection

    o       (in visual block mode) move cursor to another corner of the
            select area (to control which corner you're resizing from).

------------------------------------------------------------------------------
Named registers

    "c      refers to named register 'c', can tie to actions, e.g.
                "add        del cur line, copy into register a
                "byy        copy current line into register b
                "cy/foo     copy up to regex foo into register c
                "ap         paste from register a
                "bP         paste from register b to previous line

------------------------------------------------------------------------------
External comands

    :r!<cmd>        read in the result of a command

    !cmd            pipe selection through command, replace with result

    :echo glob($VIMRUNTIME . '/syntax/*.vim')      Show all known syntaxes

------------------------------------------------------------------------------
Undo

    u       undo
    U       undo entire line

    :undolist       see your undo tree

==============================================================================
Shortcuts (insert mode)

    ^N      try to do a completion on the current word
    ^P      try to do completion, reverse direction

==============================================================================
Macros

    q.      record macro into default register
    q       stop recording
    @.      play macro from default register

    qa, @a  using register a

==============================================================================
Plugin: surround

http://www.vim.org/scripts/script.php?script_id=1697

    cs = "change surrounding"
    ds = "delete surrounding"

    # swap double quotes for single
    cs"'   (c, s, doublequote, singlequote)

    # swap single quotes for <q>..</q>
    cs'<q>

    # swap surrounding tag, whatever it is, with double quotes
    cst"

    # remove the delimiter doublequote
    ds"

==============================================================================
Text object selections

After a command like d (delete) or c (change) you can supply delimiters
like brackets, braces.

<img src="foo-bar-baz.jpg" alt="whatever" />

    di>
    # delete inner angle-bracket
    # results in: <>

    da>
    # delete all-inclusive angle-bracket
    # results in entire thing being removed.

    ci>
    # change inner angle-bracket
    # wipes out contents, leaving you in insert mode inside to replace it.

    ca>
    # change all-inclusive angle-bracket
    # wipes out the entire tag, leaving you in insert mode to replace it.

    # you can use either delimiter in the pair, < or >, ( or ), { or },
    # [ or ] ....

    # w matches a puncuation-delimited word
    # W matches a space-delimited word

==============================================================================
Plugin: arrow-key-remap (removed this plugin to add text bubbling)

These work in both normal and insert mode. Obviously arrow keys as navigation
do not work with this plugin in place.

    Up          delete blank line above cursor
    Down        insert blank line above cursor

    Ctl-Up      delete blank line below cursor
    Ctl-Down    insert blank line below cursor

The above four can be thought of as grabbing the current line and
pulling on it to close or open a gap in the file. Use to create or
trim whitespace, etc.

    Left        de-dent current line
    Right       indent current line

==============================================================================

nnoremap <leader>1 yypVr=

replicates the current line, then replaces it with ='s
(so this gives you an = signs underline the same length as
the current line)

See mappings: ,uu ,uU

==============================================================================
From Steve Losh: Yankring

Vim’s copying and pasting functionality (which uses registers) is very, very
powerful, but it’s not exactly “user friendly”. The YankRing plugin adds a lot
more power, but also adds a few features that make copying and pasting much
more pleasant.

For example, after you paste some text you can replace that paste with the
previous item you copied with Ctrl-P. You can cycle back further by just
hitting Ctrl-P over and over.

YankRing also shares your yanked text between Vim windows, which makes things
“just work” when you want to paste text from one window into another.

You can also show a list of all your previously yanked text with :YRShow.
Mapping that command to a key is quite helpful:

    nnoremap <silent> <F3> :YRShow<cr>
    inoremap <silent> <F3> <ESC>:YRShow<cr>

YankRing offers a ton of other cool functionality but I haven’t had the time
or motivation to really dig in and find out how to use it.

==============================================================================
Variable scoping

		(nothing) In a function: local to a function; otherwise: global
|buffer-variable|    b:	  Local to the current buffer.
|window-variable|    w:	  Local to the current window.
|tabpage-variable|   t:	  Local to the current tab page.
|global-variable|    g:	  Global.
|local-variable|     l:	  Local to a function.
|script-variable|    s:	  Local to a |:source|'ed Vim script.
|function-argument|  a:	  Function argument (only inside a function).
|vim-variable|	     v:	  Global, predefined by Vim.

==============================================================================
