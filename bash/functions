
# "h" shows a tailed history
# "h <pattern>" shows all history entries matching the string
h() {
	test -n "$1" && history | grep -i "$1" || history | tail -15
}

# Make a directory, then go there
d() {
	test -n "$1" || return
	mkdir -p "$1" && cd "$1"
}

# "path" shows current path, one element per line.
# If an argument is supplied, grep for it.
path() {
	test -n "$1" && {
		echo $PATH | perl -p -e 's/:/\n/g;' | grep -i "$1"
	} || {
		echo $PATH | perl -p -e 's/:/\n/g;'
	}
}

# Look up error codes
errno() {
	perl -e "\$! = $1; print \"\$! \\n\";"
}

# Machine type, on Solaris systems
hw() {
	[[ "$OS" != "SunOS" ]] && {
		echo "'hw' is only available in SunOS."
		return
	}
	prtdiag | head -1 | \
		sed "s/^System Configuration: *Sun Microsystems *//" | \
		sed "s/^`uname -m` *//"
}

# Translate AS numbers / RR communities
astr() {
	echo "$1" | tr '[A-J0-9]' '[0-9A-J]'
}

# Look for code repositories. If git, show me the branch name. If CVS or
# Subversion, just show me the repo type (they don't have good branch info).
# Preserve the value of $? by returning it as we received it.
_scm_info() {
	local _retval=$?
	local _gb

	if [[ -f ./CVS/Root ]]; then
		echo -n ' (CVS)'
	elif [[ -d ./.svn ]]; then
		echo -n ' (Subversion)'
	else
		_gb=`git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'`
		test -n "$_gb" && echo -n " ($_gb)"
	fi

	return $_retval
}

# Create a new git repo in cwd
gitinit() {
	git init
	printf ".DS_Store\n.*.swp\n*~\n" > .gitignore
}

# Give me a shortened version of the local hostname.
# If it's 1-3 atoms, give me only the first.
# If it's more than that, give me the first two.
# Preserve the value of $? by returning it as we received it.
_short_hname() {
	local _retval=$?

	echo $HOST | perl -p -e '
		if ( scalar( split( /\./ ) ) > 3 ) {
			s/^([^.]+\.[^.]+).*$/$1/;
		} else {
			s/^([^.]+).*$/$1/;
		}
	'

	# Alternate version from Ravi Pina. Much shorter, but it gives
	# you three atoms on long names, not two, and on a single
	# atom it doesn't return anything at all.
	#perl -le '$ENV{HOST}=~/^((?:[^.]+\.){2}[^.]+|[^.]+)\./;print$1'

	return $_retval
}

# Check to see if I have local mail on this system. If mail is waiting,
# output a few chars that are supposed to resemble an envelope.
_check_for_mail() {
	local _retval=$?
	local _mail_cmd

	_mail_cmd=$(command -v mail >/dev/null 2>&1)

	test -n "$_mail_cmd" && {
		$_mail_cmd -e >/dev/null 2>&1
		if [[ $? -eq 0 ]]; then
			echo -n "|><| "
		fi
	}

	return $_retval
}

# Output an extended color (256-color support). If one color is provided,
# set the foreground. If two are provided, set {foreground, background}.
# Preserve the value of $? by returning it as we received it.
_xc() {
	local _retval=$?

	echo -ne "\033[m\033[38;5;$1m"
	test -n "$2" && echo -ne "\033[48;5;$2m"

	return $_retval
}

# Make the foreground color bold instead of normal.
# Preserve the value of $? by returning it as we received it.
_xcb() {
	local _retval=$?

	echo -ne "\033[1m"
	_xc $@

	return $_retval
}

# Set back to normal colors (reset).
# Preserve the value of $? by returning it as we received it.
_xcr() {
	local _retval=$?

	echo -ne "\033[m"

	return $_retval
}

# Evaluate $? and return an attention-grabbing color if non-zero.
# Preserve the original value of $? by returning it as we received it.
_xc_retval() {
	local _retval=$?

	[[ $_retval != 0 ]] && echo -ne "\033[1m\033[38;5;196m"

	return $_retval
}

# Get job count, return an attention grabbing color if there are > 0.
# Preserve the original value of $? by returning it as we received it.
_xc_jobs() {
	local _retval=$?

	local _jobcount=`jobs|wc -l`
	[[ $_jobcount -gt 0 ]] && echo -ne "\033[1m\033[38;5;214m"

	return $_retval
}

# Used by ff(), fd()... execute a find command, possible filtering results
_finder() {
	local _type="$1"
	local _include="$2"
	local _exclude="$3"

	test -n "$_type" || return

	if [[ -n "$_exclude" ]]; then
		find . -type $_type -print | grep -i "$_include" | grep -vi "$_exclude"
	elif [[ -n "$_include" ]]; then
		find . -type $_type -print | grep -i "$_include"
	else
		find . -type $_type -print
	fi
}

# Show file tree, optionally filtering results
ff() {
	if [[ "$1" =~ ^\(-h\|--help\) ]]; then
		echo "Usage: ff [<include-pattern>] [<exclude-pattern>]"
		return
	fi

	_finder f "$1" "$2"
}

# Show directory tree, optionally filtering results
fd() {
	if [[ "$1" =~ ^\(-h\|--help\) ]]; then
		echo "Usage: fd [<include-pattern>] [<exclude-pattern>]"
		return
	fi

	_finder d "$1" "$2"
}

# Example function: how to set a window title
#function settitle() {
 	#echo -ne "\033]2;Title Goes Here\a"
#}

# Example function: how to set an iTerm *tab* title independent of window title
#function settabtitle() {
	#echo -ne "\033]1;Title Goes Here\a"
#}

# Tell me the installed version of a Perl module.
perlmodver() {
	local _module="$1"

	test -n "$_module" || { echo "missing argument"; return; }
	perl -M$_module -e "print \$$_module::VERSION,\"\\n\";"
}

# Move backward through the directory tree easily. When called without
# an argument, goes back one level ('cd ..'). When called with a numeric
# argument, goes back that many levels.
#       '.. 2' = 'cd ../..'
#       '.. 3' = 'cd ../../..'
#       '.. 4' = 'cd ../../../..'
..() {
	local _count
	test -n "$1" && _count="$1" || _count="1"
	while [[ "$_count" > 0 ]]; do
		cd ..
		_count=$((_count - 1))
	done
}

# Pull changes for all the dotfiles submodules
update_dotfile_submodules() {
	local _module
	local _base="$HOME/.dotfiles"

	cd $_base
	for _module in `git submodule | awk '{print $2}'`; do
		echo "[[ $_module ]]"
		cd $_base/$_module
		git pull origin HEAD
	done

	cd $_base
	git status
}

