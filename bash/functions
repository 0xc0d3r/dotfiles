
# "h" shows a tailed history
# "h <pattern>" shows all history entries matching the string
h() {
	test -n "$1" && history | grep -i "$1" || history | tail -15
}

# Make a directory, then go there
d() {
	test -n "$1" || return
	mkdir "$1" && cd "$1"
}

# "path" shows current path, one element per line.
# If an argument is supplied, grep for it.
path() {
	test -n "$1" && {
		echo $PATH | perl -p -e 's/:/\n/g;' | grep -i "$1"
	} || {
		echo $PATH | perl -p -e 's/:/\n/g;'
	}
}

# Look up error codes
errno() {
	perl -e "\$! = $1; print \"\$! \\n\";"
}

# machine type, on solaris
hw() {
	[[ "$OS" != "SunOS" ]] && {
		echo "'hw' is only available in SunOS."
		return
	}
	prtdiag | head -1 | \
		sed "s/^System Configuration: *Sun Microsystems *//" | \
		sed "s/^`uname -m` *//"
}

# Translate AS numbers / RR communities
astr() {
	echo "$1" | tr '[A-J0-9]' '[0-9A-J]'
}

# Look for code repositories. If git, show me the branch name. If CVS or
# Subversion, just show me the repo type (they don't have good branch info).
# Preserve the value of $? by returning it as we received it.
_scm_info() {
	local _retval=$?
	local _gb

	if [[ -f ./CVS/Root ]]; then
		echo -n ' (CVS)'
	elif [[ -d ./.svn ]]; then
		echo -n ' (Subversion)'
	else
		_gb=`git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'`
		test -n "$_gb" && echo -n " ($_gb)"
	fi

	return $_retval
}

# Create a new git repo in cwd
gitinit() {
	git init
	printf ".DS_Store\n.*.swp\n*~\n" > .gitignore
}

# NTT git environment is a little weird, streamline it.
gitclone_ntt() {
	local _path="/usr/local/bin/git-upload-pack"
	local _user="dan"
	local _server="admin1.mlpsca01.us.to.gin.ntt.net"

	test -n "$1" || {
		echo "Missing argument (repo to clone)"
		return
	}

	git clone -o ntt -u $_path ssh://$_user@$_server/~/git/$1 $2
}

gitpush_ntt() {
	local _gituser="dan@admin1.mlpsca01.us.to.gin.ntt.net"

	test -n "$1" || {
		echo "Missing argument (remote repo name)"
		return
	}

	git remote add ntt ssh://$_gituser/~/git/$1
	git push ntt master
	git branch --set-upstream master ntt/master
}

# Give me a shortened version of the local hostname.
# If it's 1-3 atoms, give me only the first.
# If it's more than that, give me the first two.
# Preserve the value of $? by returning it as we received it.
_short_hname() {
	local _retval=$?

	echo $HOST | perl -p -e '
		if ( scalar( split( /\./ ) ) > 3 ) {
			s/^([^.]+\.[^.]+).*$/$1/;
		} else {
			s/^([^.]+).*$/$1/;
		}
	'

	# Alternate version from Ravi Pina. Much shorter, but it gives
	# you three atoms on long names, not two, and on a single
	# atom it doesn't return anything at all.
	#perl -le '$ENV{HOST}=~/^((?:[^.]+\.){2}[^.]+|[^.]+)\./;print$1'

	return $_retval
}

# Output an extended color (256-color support). If one color is provided,
# set the foreground. If two are provided, set {foreground, background}.
# Preserve the value of $? by returning it as we received it.
_xc() {
	local _retval=$?

	echo -ne "\033[m\033[38;5;$1m"
	test -n "$2" && echo -ne "\033[48;5;$2m"

	return $_retval
}

# Make the foreground color bold instead of normal.
# Preserve the value of $? by returning it as we received it.
_xcb() {
	local _retval=$?

	echo -ne "\033[1m"
	_xc $@

	return $_retval
}

# Set back to normal colors (reset).
# Preserve the value of $? by returning it as we received it.
_xcr() {
	local _retval=$?

	echo -ne "\033[m"

	return $_retval
}

# Evaluate $? and return an attention-grabbing color if non-zero.
# Preserve the original value of $? by returning it as we received it.
_xc_retval() {
	local _retval=$?

	[[ $_retval != 0 ]] && echo -ne "\033[1m\033[38;5;196m"

	return $_retval
}

# Get job count, return an attention grabbing color if there are > 0.
# Preserve the original value of $? by returning it as we received it.
_xc_jobs() {
	local _retval=$?

	local _jobcount=`jobs|wc -l`
	[[ $_jobcount -gt 0 ]] && echo -ne "\033[1m\033[38;5;214m"

	return $_retval
}

# Used by ff(), fd()... execute a find command, possible filtering results
_finder() {
	local _type="$1"
	local _include="$2"
	local _exclude="$3"

	test -n "$_type" || return

	if [[ -n "$_exclude" ]]; then
		find . -type $_type -print | grep -i "$_include" | grep -vi "$_exclude"
	elif [[ -n "$_include" ]]; then
		find . -type $_type -print | grep -i "$_include"
	else
		find . -type $_type -print
	fi
}

# Show file tree, optionally filtering results
ff() {
	if [[ "$1" =~ ^\(-h\|--help\) ]]; then
		echo "Usage: ff [<include-pattern>] [<exclude-pattern>]"
		return
	fi

	_finder f "$1" "$2"
}

# Show directory tree, optionally filtering results
fd() {
	if [[ "$1" =~ ^\(-h\|--help\) ]]; then
		echo "Usage: fd [<include-pattern>] [<exclude-pattern>]"
		return
	fi

	_finder d "$1" "$2"
}

# Example function: how to set a window title
#function settitle() {
 	#echo -ne "\033]2;Title Goes Here\a"
#}

# Example function: how to set an iTerm *tab* title independent of window title
#function settabtitle() {
	#echo -ne "\033]1;Title Goes Here\a"
#}

# Tell me the installed version of a Perl module.
perlmodver() {
	local _module="$1"

	test -n "$_module" || { echo "missing argument"; return; }
	perl -M$_module -e "print \$$_module::VERSION,\"\\n\";"
}

