
# "h" shows a tailed history
# "h <pattern>" shows all history entries matching the string
function h() {
	test -n "$1" && history | grep -i "$1" || history | tail -15
}

# Make a directory, then go there
function d() {
	test -n "$1" || return
	mkdir "$1" && cd "$1"
}

# "path" shows current path, one element per line.
# If an argument is supplied, grep for it.
function path() {
	test -n "$1" && {
		echo $PATH | perl -p -e 's/:/\n/g;' | grep -i "$1"
	} || {
		echo $PATH | perl -p -e 's/:/\n/g;'
	}
}

# Look up error codes
function errno() {
	perl -e "\$! = $1; print \"\$! \\n\";"
}

# machine type, on solaris
function hw() {
	[[ "$OS" != "SunOS" ]] && {
		echo "'hw' is only available in SunOS."
		return
	}
	prtdiag | head -1 | \
		sed "s/^System Configuration: *Sun Microsystems *//" | \
		sed "s/^`uname -m` *//"
}

# Translate AS numbers / RR communities
function astr() {
	echo "$1" | tr '[A-J0-9]' '[0-9A-J]'
}

# Look for code repositories. If git, show me the branch name. If CVS or
# Subversion, just show me the repo type (they don't have good branch info).
# Preserve the value of $? by returning it as we received it.
function _scm_info() {
	_retval=$?

	if [[ -f ./CVS/Root ]]; then
		echo -n ' (CVS)'
	elif [[ -d ./.svn ]]; then
		echo -n ' (Subversion)'
	else
		_gb=`git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'`
		test -n "$_gb" && echo -n " ($_gb)"
	fi

	return $_retval
}

# Create a new git repo in cwd
function gitinit() {
	git init
	printf ".DS_Store\n.*.swp\n*~\n" > .gitignore
}

# NTT git environment is a little weird, streamline it.
function gitclone_ntt() {
	_path="/usr/local/bin/git-upload-pack"
	_user="dan"
	_server="admin1.mlpsca01.us.to.gin.ntt.net"

	test -n "$1" || {
		echo "Missing argument (repo to clone)"
		return
	}

	git clone -o ntt -u $_path ssh://$_user@$_server/~/git/$1 $2
}

function gitpush_ntt() {
	_gituser="dan@admin1.mlpsca01.us.to.gin.ntt.net"
	test -n "$1" || {
		echo "Missing argument (remote repo name)"
		return
	}
	git remote add ntt ssh://$_gituser/~/git/$1
	git push ntt master
	git branch --set-upstream master ntt/master
}

# Give me a shortened version of the local hostname.
# If it's 1-3 atoms, give me only the first.
# If it's more than that, give me the first two.
# Preserve the value of $? by returning it as we received it.
function _short_hname() {
	_retval=$?

	echo $HOST | perl -p -e '
		if ( scalar( split( /\./ ) ) > 3 ) {
			s/^([^.]+\.[^.]+).*$/$1/;
		} else {
			s/^([^.]+).*$/$1/;
		}
	'

	# Alternate version from Ravi Pina. Much shorter, but it gives
	# you three atoms on long names, not two, and on a single
	# atom it doesn't return anything at all.
	#perl -le '$ENV{HOST}=~/^((?:[^.]+\.){2}[^.]+|[^.]+)\./;print$1'

	return $_retval
}

# Output an extended color (256-color support). If one color is provided,
# set the foreground. If two are provided, set {foreground, background}.
# Preserve the value of $? by returning it as we received it.
function _xc() {
	_retval=$?
	echo -ne "\033[m\033[38;5;$1m"
	test -n "$2" && echo -ne "\033[48;5;$2m"
	return $_retval
}

# Make the foreground color bold instead of normal.
# Preserve the value of $? by returning it as we received it.
function _xcb() {
	_retval=$?
	echo -ne "\033[1m"
	_xc $@
	return $_retval
}

# Set back to normal colors (reset).
# Preserve the value of $? by returning it as we received it.
function _xcr() {
	_retval=$?
	echo -ne "\033[m"
	return $_retval
}

# Evaluate $? and return an attention-grabbing color if non-zero.
# Preserve the original value of $? by returning it as we received it.
function _xc_retval() {
	_retval=$?
	[[ $_retval != 0 ]] && echo -ne "\033[1m\033[38;5;196m"
	return $_retval
}

# Get job count, return an attention grabbing color if there are > 0.
# Preserve the original value of $? by returning it as we received it.
function _xc_jobs() {
	_retval=$?
	_jobcount=`jobs|wc -l`
	[[ $_jobcount -gt 0 ]] && echo -ne "\033[1m\033[38;5;214m"
	return $_retval
}

# Used by ff(), fd()... execute a find command, possible filtering results
function _finder() {
	_type="$1"
	_pattern="$2"

	test -n "$_type" || return

	if [[ -n "$_pattern" ]]; then
		find . -type $_type -print | grep -i "$_pattern"
	else
		find . -type $_type -print
	fi
}

# Show file tree, optionally filtering results
function ff() {
	_finder f $1
}

# Show directory tree, optionally filtering results
function fd() {
	_finder d $1
}

# Example function: how to set a window title
#function settitle() {
 	#echo -ne "\033]2;Title Goes Here\a"
#}

# Example function: how to set an iTerm *tab* title independent of window title
#function settabtitle() {
	#echo -ne "\033]1;Title Goes Here\a"
#}

