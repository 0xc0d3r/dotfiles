
# "h" shows a tailed history
# "h <pattern>" shows all history entries matching the string
function h {
	test -n "$1" && { history | grep -i "$1"; } || { history | tail -15; }
}

# Make a directory, then go there
function md {
	test -n "$1" || return
	mkdir -p "$1" && cd "$1"
}

# "path" shows current path, one element per line.
# If an argument is supplied, grep for it.
function path {
	test -n "$1" && {
		echo $PATH | perl -p -e 's/:/\n/g;' | grep -i "$1"
	} || {
		echo $PATH | perl -p -e 's/:/\n/g;'
	}
}

# Look up error codes
function errno {
	perl -e "\$! = $1; print \"\$! \\n\";"
}

# Machine type, on Solaris systems
function hw {
	[[ "$OS" != "SunOS" ]] && {
		echo "'hw' is only available in SunOS."
		return
	}
	/usr/platform/`uname -m`/sbin/prtdiag | head -1 | \
		sed "s/^System Configuration: *Sun Microsystems *//" | \
		sed "s/^`uname -m` *//"
}

# Translate AS numbers / RR communities
function astr {
	echo "$1" | tr '[A-J0-9]' '[0-9A-J]'
}

# Check if we're in a CVS repository
function is_cvs_repository {
	test -f ./CVS/Root > /dev/null 2>&1
}

# Check if we're in a Subversion repository
function is_svn_repository {
	test -d ./.svn > /dev/null 2>&1
}

# Check if we're in a git repository
function is_git_repository {
	git branch > /dev/null 2>&1
}

# Figure out our SCM coloring.
function _scm_color {
	local _retval=$?
	local _git_status
	
	# First check for CVS, then Subversion
	is_cvs_repository && { _xc 36; return $_retval; }
	is_svn_repository && { _xc 36; return $_retval; }
	
	# If we got here and it's not a Git repo either, just bail
	is_git_repository || return $_retval
	
	# If we're still here, figure out the color we want to use
	_git_status="$(git status 2>/dev/null)"
	
	if [[ $_git_status =~ "working directory clean" ]]; then
		_xc 36
	elif [[ $_git_status =~ "Changes to be committed" ]]; then
		_xc 33
	else
		# something weird? go with red
		_xc 31
	fi
	
	return $_retval
}

# Look for code repositories. If git, show me the branch name. If CVS or
# Subversion, just show me the repo type (they don't have good branch info).
# Preserve the value of $? by returning it as we received it.
function _scm_info {
	local _retval=$?
	local _branch
	local _git_status
	local _pattern
	local _remote
	
	# First check for CVS, then Subversion
	is_cvs_repository && { echo -n " (CVS)";        return $_retval; }
	is_svn_repository && { echo -n " (Subversion)"; return $_retval; }
	
	# If we're still here, see if it's Git; if not, just bail
	is_git_repository || return $_retval
	
	_git_status="$(git status 2>/dev/null)"

	# Set arrow icon based on status against remote.
	_pattern="# Your branch is (.*) of"
	if [[ $_git_status =~ $_pattern ]]; then
		if [[ ${BASH_REMATCH[1]} == "ahead" ]]; then
			_remote="↑"
		else
			_remote="↓"
		fi
	fi
	_pattern="# Your branch and (.*) have diverged"
	if [[ $_git_status =~ $_pattern ]]; then
		remote="↕"
	fi
	
	# Get the name of the branch.
	_pattern="^# On branch ([^${IFS}]*)"
	if [[ $_git_status =~ $_pattern ]]; then
		_branch=${BASH_REMATCH[1]}
	fi
	
	# Output the prompt.
	echo -n " ($_branch)${_remote}"

	return $_retval
}

# Create a new git repo in cwd
function gitinit {
	git init
	printf ".DS_Store\n.*.swp\n*~\n" > .gitignore
}

# Give me a shortened version of the local hostname.
# If it's 1-3 atoms, give me only the first.
# If it's more than that, give me the first two.
# Preserve the value of $? by returning it as we received it.
function _short_hname {
	local _retval=$?

	echo $HOST | perl -p -e '
		if (scalar(split(/\./)) > 3) {
			s/^([^.]+\.[^.]+).*$/$1/;
		} else {
			s/^([^.]+).*$/$1/;
		}
	'

	# Alternate version from Ravi Pina. Much shorter, but it gives
	# you three atoms on long names, not two, and on a single
	# atom it doesn't return anything at all.
	#perl -le '$ENV{HOST}=~/^((?:[^.]+\.){2}[^.]+|[^.]+)\./;print$1'

	return $_retval
}

# Check to see if I have local mail on this system. If mail is waiting,
# output a few chars that are supposed to resemble an envelope.
function _check_for_mail {
	local _retval=$?
	local _mail_cmd

	_mail_cmd=$(command -v mail 2>/dev/null)

	test -n "$_mail_cmd" && {
		$_mail_cmd -e >/dev/null 2>&1
		[[ $? -eq 0 ]] && echo -n "|><| "
	}

	return $_retval
}

# Output a color.
# Preserve the value of $? by returning it as we received it.
function _xc {
	local _retval=$?
	echo -ne "\033[$1m"
	return $_retval
}

# Make the colored text underscored
function _xcu {
	local _retval=$?
	echo -ne "\033[$1;4m"
	return $_retval
}

# Make the foreground color bold (bright) instead of normal.
# Preserve the value of $? by returning it as we received it.
function _xcb {
	local _retval=$?
	echo -ne "\033[1;$1m"
	return $_retval
}

# Set back to normal colors (reset).
# Preserve the value of $? by returning it as we received it.
function _xcr {
	local _retval=$?
	echo -ne "\033[0m"
	return $_retval
}

# Evaluate $? and return an attention-grabbing color if non-zero.
# Preserve the original value of $? by returning it as we received it.
# 31 = red
# 7 = reverse
function _xc_retval {
	local _retval=$?
	[[ $_retval != 0 ]] && echo -ne "\033[31;7m"
	return $_retval
}

# Get job count, return an attention grabbing color if there are > 0.
# Preserve the original value of $? by returning it as we received it.
# 31 = red
function _xc_jobs {
	local _retval=$?
	local _jobcount=`jobs | wc -l`
	[[ $_jobcount -gt 0 ]] && _xc 31
	return $_retval
}

# Used by ff(), fd()... execute a find command, possible filtering results
function _finder {
	local _type="$1"
	local _include="$2"
	local _exclude="$3"

	test -n "$_type" || return

	if [[ -n "$_exclude" ]]; then
		find . -type $_type -print | grep -i "$_include" | grep -vi "$_exclude"
	elif [[ -n "$_include" ]]; then
		find . -type $_type -print | grep -i "$_include"
	else
		find . -type $_type -print
	fi
}

# Show file tree, optionally filtering results
function ff {
	if [[ "$1" =~ ^\(-h\|--help\) ]]; then
		echo "Usage: ff [<include-pattern>] [<exclude-pattern>]"
		return
	fi

	_finder f "$1" "$2"
}

# Show directory tree, optionally filtering results
function fd {
	if [[ "$1" =~ ^\(-h\|--help\) ]]; then
		echo "Usage: fd [<include-pattern>] [<exclude-pattern>]"
		return
	fi

	_finder d "$1" "$2"
}

# Set a window title
function set_window_title {
	echo -ne "\033]2;$1\a"
}

# Set an iTerm2 *tab* title independent of window title
function set_tab_title {
	echo -ne "\033]1;$1\a"
}

# Set both window and tab titles
function set_titles {
	set_window_title "$1"
	set_tab_title "$1"
}

# Steal focus
function steal_focus {
	echo -ne "\033]50;StealFocus\a"
}

# Tell me the installed version of a Perl module.
function perlmodver {
	local _module="$1"

	test -n "$_module" || { echo "missing argument"; return; }
	perl -M$_module -e "print \$$_module::VERSION,\"\\n\";"
}

# Move backward through the directory tree easily. When called without
# an argument, goes back one level ('cd ..'). When called with a numeric
# argument, goes back that many levels.
#       '.. 2' = 'cd ../..'
#       '.. 3' = 'cd ../../..'
#       '.. 4' = 'cd ../../../..'
function .. {
	local _count
	test -n "$1" && _count="$1" || _count="1"
	while [[ "$_count" > 0 ]]; do
		cd ..
		_count=$((_count - 1))
	done
}

# Test for a perl module and print its version if any.
function pmver {
	local _module="$1"

	if [[ -z "$_module" ]]; then
		echo "Missing argument (module name)"
		return
	fi

	perl -M$_module -e "print \"\$${_module}::VERSION\n\";"
}

# Beep the terminal. If a time is specified, wait that number
# of seconds, then beep.
function beep {
	test -n "$1" && sleep $1
	echo -ne "\a"
}

# Make a new puppet module
function mkpuppetmodule {
	[[ -d $1 ]] && { echo "directory '$1' already exists"; return; }
	mkdir -p $1/{files,templates,manifests}
	cd $1
	ls -l
}

