
# "h" shows entire history
# "h <pattern>" shows you history entries matching the string
# ht is the same thing, but runs it through tail -20.
function h() {
	test -n "$1" && history | grep -i "$1" || history
}

# Look up error codes
function errno() {
	perl -e "\$! = $1; print \"\$! \\n\";"
}

# machine type, on solaris
function hw() {
	[[ "$OS" != "SunOS" ]] && {
		echo "'hw' is only available in SunOS."
		return
	}
	prtdiag | head -1 | \
		sed "s/^System Configuration: *Sun Microsystems *//" | \
		sed "s/^`uname -m` *//"
}

# Translate AS numbers / RR communities
function astr() {
	echo "$1" | tr '[A-J0-9]' '[0-9A-J]'
}

# Get the current git branch (for shell prompt).
# _preserve passes through $? unmolested, both for displaying it in the prompt
# and for using it generally.
function _git_branch() {
	_preserve=$?
	git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
	return $_preserve
}

# Easy clone of a project that lives on Dreamhost
function gitclone_dreamhost() {
	_user="scsiboy"
	_server="git.tangledhelix.com"

	test -n "$1" || {
		echo "Missing argument (repo to clone)"
		return
	}

	git clone ssh://$_user@$_server/~/git/$1 $2
}

# NTT git environment is a little weird, streamline it.
function gitclone_ntt() {
	_path="/usr/local/bin/git-upload-pack"
	_user="dan"
	_server="admin1.mlpsca01.us.to.gin.ntt.net"

	test -n "$1" || {
		echo "Missing argument (repo to clone)"
		return
	}

	git clone -o ntt -u $_path ssh://$_user@$_server/~/git/$1 $2
}

# Give me a shortened version of the local hostname.
# If it's 1-3 atoms, give me only the first.
# If it's more than that, give me the first two.
function _short_hname() {

	echo $HOST | perl -p -e '
		if ( scalar( split( /\./ ) ) > 3 ) {
			s/^([^.]+\.[^.]+).*$/$1/;
		} else {
			s/^([^.]+).*$/$1/;
		}
	'

	# Alternate version from Ravi. Much shorter, but it gives
	# you three atoms on long names, not two, and on a single
	# atom it doesn't return anything at all.
	#perl -le '$ENV{HOST}=~/^((?:[^.]+\.){2}[^.]+|[^.]+)\./;print$1'

}

# Output an extended color (256-color support). If one color is provided,
# set the foreground. If two are provided, set {foreground, background}.
function _xc() {
	_preserve=$?
	echo -ne "\[\033[38;05;$1m\]"
	test -n "$2" && echo -ne "\[\033[48;05;$2m\]"
	return $_preserve
}

# Make the color bold instead of normal.
function _xc_bold() {
	_preserve=$?
	echo -ne "\[\033[01m\]"
	_xc $@
	return $_preserve
}

# Set back to normal colors.
function _xc_reset() {
	_preserve=$?
	echo -ne "\[\033[0m\]"
	return $_preserve
}

# Give me a retval that's colorized based on its value. For some reason I have
# to embed the escape codes directly; I can't use the _xc function.
function _color_retval() {
	_retval=$?
	if [[ $_retval == 0 ]]; then
		echo -ne "\033[0m$_retval"
	else
		echo -ne "\033[1m\033[38;5;196m$_retval\033[0m"
	fi
	return $_retval
}

